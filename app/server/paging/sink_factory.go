package paging

import (
	"context"
	"fmt"
	"sync"

	"go.uber.org/zap"

	api_service_protos "github.com/ydb-platform/fq-connector-go/api/service/protos"
	"github.com/ydb-platform/fq-connector-go/app/config"
	"github.com/ydb-platform/ydb-go-genproto/protos/Ydb"
)

//go:generate stringer -type=sinkFactoryState
type sinkFactoryState int8

const (
	sinkFactoryOperational sinkFactoryState = iota
	sinkFactoryTerminating
	sinkFactoryTerminated
)

// SinkFactory should be instantiated once for each ReadSplits request.
// It owns some structures that are shared across multiple Sink instances.
type sinkFactoryImpl[T Acceptor] struct {
	ctx           context.Context
	logger        *zap.Logger
	cfg           *config.TPagingConfig
	resultQueue   chan *ReadResult[T]      // outgoing buffer queue
	terminateChan chan *sinkImpl[T]        // used by Sinks to notify factory about their termination
	bufferFactory ColumnarBufferFactory[T] // factory responsible for ColumnarBuffer generation
	readLimiter   ReadLimiter              // helps to restrict the number of rows read in every request

	// mutable fields with synchronized access
	totalSinks uint8
	children   map[*sinkImpl[T]]struct{}
	state      sinkFactoryState
	mutex      sync.Mutex
}

// MakeSink is used to generate Sink objects, one per each data source connection.
func (f *sinkFactoryImpl[T]) MakeSink(logger *zap.Logger, ydbTypes []*Ydb.Type) (Sink[T], error) {
	if f.state != sinkFactoryOperational {
		return nil, fmt.Errorf("unexpected sink factory state: %s", f.state)
	}

	buffer, err := f.bufferFactory.MakeBuffer(ydbTypes)
	if err != nil {
		return nil, fmt.Errorf("make buffer: %w", err)
	}

	sink := &sinkImpl[T]{
		bufferFactory:  f.bufferFactory,
		readLimiter:    f.readLimiter,
		resultQueue:    f.resultQueue, // result queue is shared across multiple Sink instances
		terminateChan:  f.terminateChan,
		trafficTracker: newTrafficTracker[T](f.cfg),
		currBuffer:     buffer,
		logger:         logger,
		ydbTypes:       ydbTypes,
		state:          sinkOperational,
		ctx:            f.ctx,
	}

	f.totalSinks++
	f.children[sink] = struct{}{}

	return sink, nil
}

// ResultQueue returns a channel with columnar buffers generated by all sinks
func (f *sinkFactoryImpl[T]) ResultQueue() <-chan *ReadResult[T] {
	return f.resultQueue
}

// FinalStats returns the overall statistics collected during the request processing.
func (f *sinkFactoryImpl[T]) FinalStats() *api_service_protos.TReadSplitsResponse_TStats {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	overallStats := &api_service_protos.TReadSplitsResponse_TStats{}

	for sink := range f.children {
		partialStats := sink.trafficTracker.DumpStats(true)
		overallStats.Rows += partialStats.Rows
		overallStats.Bytes += partialStats.Bytes
	}

	return overallStats
}

// Waiting in the background for the children termination in order to close the result queue.
func (f *sinkFactoryImpl[T]) awaitTermination() {
	for {
		select {
		case sink := <-f.terminateChan:
			f.handleTerminationEvent(sink)
		case <-f.ctx.Done():
			return
		}
	}
}

func (f *sinkFactoryImpl[T]) handleTerminationEvent(sink *sinkImpl[T]) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	switch f.state {
	case sinkFactoryOperational:
		f.state = sinkFactoryTerminating
	case sinkFactoryTerminating:
		break
	case sinkFactoryTerminated:
		panic("impossible state")
	}

	delete(f.children, sink)

	sink.logger.Debug("sink terminated", zap.Int("total_sinks", int(f.totalSinks)), zap.Int("sinks_left", len(f.children)))

	if len(f.children) == 0 {
		// notify reader about the end of data
		f.logger.Info("all sinks terminated")
		close(f.resultQueue)
		f.state = sinkFactoryTerminated
	}
}

func NewSinkFactory[T Acceptor](
	ctx context.Context,
	logger *zap.Logger,
	cfg *config.TPagingConfig,
	columnarBufferFactory ColumnarBufferFactory[T],
	readLimiter ReadLimiter,
) SinkFactory[T] {
	sf := &sinkFactoryImpl[T]{
		bufferFactory: columnarBufferFactory,
		readLimiter:   readLimiter,
		resultQueue:   make(chan *ReadResult[T], cfg.PrefetchQueueCapacity),
		totalSinks:    0,
		terminateChan: make(chan *sinkImpl[T]),
		children:      make(map[*sinkImpl[T]]struct{}),
		cfg:           cfg,
		ctx:           ctx,
		logger:        logger,
	}

	go sf.awaitTermination()

	return sf
}
